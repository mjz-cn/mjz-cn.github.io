<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Flink源码分析-Watermark - MJZ</title><meta description="简介窗口机制是Flink流处理的核心，它将无限的流元素分割成有限的窗口。当一个窗口不再增加新元素时，就可以对这个窗口中的所有元素执行计算逻辑。而判断窗口不会再增加新元素的方式有：时间（Watermark）、计数、自定义。其中Watermark代表事件发生时的时间戳或者Flink收到事件时的时间戳。"><meta property="og:type" content="blog"><meta property="og:title" content="Flink源码分析-Watermark"><meta property="og:url" content="http://yoursite.com/2020/03/02/Flink%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Watermark%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="MJZ"><meta property="og:description" content="简介窗口机制是Flink流处理的核心，它将无限的流元素分割成有限的窗口。当一个窗口不再增加新元素时，就可以对这个窗口中的所有元素执行计算逻辑。而判断窗口不会再增加新元素的方式有：时间（Watermark）、计数、自定义。其中Watermark代表事件发生时的时间戳或者Flink收到事件时的时间戳。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://yoursite.com/assets/img/sourcestream.jpg"><meta property="og:image" content="http://yoursite.com/assets/img/downstream.jpg"><meta property="og:image" content="http://yoursite.com/assets/img/inputwatermark.jpg"><meta property="article:published_time" content="2020-03-02T14:28:00.000Z"><meta property="article:modified_time" content="2020-08-23T08:18:49.000Z"><meta property="article:author" content="文哲思"><meta property="article:tag" content="Flink源码"><meta property="article:tag" content="Flink"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/assets/img/sourcestream.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/03/02/Flink%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Watermark%E5%8E%9F%E7%90%86/"},"headline":"MJZ","image":["http://yoursite.com/assets/img/sourcestream.jpg","http://yoursite.com/assets/img/downstream.jpg","http://yoursite.com/assets/img/inputwatermark.jpg"],"datePublished":"2020-03-02T14:28:00.000Z","dateModified":"2020-08-23T08:18:49.000Z","author":{"@type":"Person","name":"文哲思"},"description":"简介窗口机制是Flink流处理的核心，它将无限的流元素分割成有限的窗口。当一个窗口不再增加新元素时，就可以对这个窗口中的所有元素执行计算逻辑。而判断窗口不会再增加新元素的方式有：时间（Watermark）、计数、自定义。其中Watermark代表事件发生时的时间戳或者Flink收到事件时的时间戳。"}</script><link rel="canonical" href="http://yoursite.com/2020/03/02/Flink%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Watermark%E5%8E%9F%E7%90%86/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?c05cacbf6d3a27ec0411cfd0506c667e";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-FZ7TCJWXRF" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-FZ7TCJWXRF');</script><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">MJZ</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/2019/12/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">参考资料</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><div class="level-item has-text-grey" datetime="{date_xml(page.date)}">发布于：2020-03-02</div><span class="level-item"> 文哲思 </span><span class="level-item"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span> / </span><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%A1%E7%AE%97/">计算</a></span><span class="level-item">13 分钟 读完 (大约 1905 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Flink源码分析-Watermark</h1><div class="content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>窗口机制是Flink流处理的核心，它将无限的流元素分割成有限的窗口。当一个窗口不再增加新元素时，就可以对这个窗口中的所有元素执行计算逻辑。而判断窗口不会再增加新元素的方式有：时间（Watermark）、计数、自定义。其中<code>Watermark</code>代表事件发生时的时间戳或者Flink收到事件时的时间戳。</p>
<a id="more"></a>

<p><code>Watermark</code>可以分为三个部分来理解：</p>
<ul>
<li>来源 <code>Watermark</code>的来源，它是如何产生的？在不同的配置下，它的产生方式有什么不同？</li>
<li>流转 当产生了一个<code>Watermark</code>时，它流转到<code>WindowOperator</code>时都会经过哪些过程？</li>
<li>触发 当<code>WindowOperator</code>收到<code>Watermark</code>时，如何处理？这个过程是通过触发器来处理的，用户可以自定义触发器，也可以使用系统提供的触发器，可参考下<code>EventTimeTrigger</code>的实现。本章不再叙述</li>
</ul>
<blockquote>
<p>注意：<code>Watermark</code>如果不能及时产生或者流转到<code>WindowOperator</code>就会造成窗口计算的延迟甚至导致窗口一直不会被触发。</p>
</blockquote>
<h2 id="Watermark来源"><a href="#Watermark来源" class="headerlink" title="Watermark来源"></a>Watermark来源</h2><p>Watermark的来源有三种：</p>
<ol>
<li><code>AutomaticWatermarkContext</code>自动以系统时间来做为<code>Watermark</code>，只能发生在<code>SourceTask</code></li>
<li>用户主动调用<code>SourceContext.emitWark()</code>，只能发生在<code>SourceTask</code></li>
<li><code>TimestampsAndPeriodicWatermarksOperator</code>从elemet中提取出<code>Watermark</code>，通过定时任务发射<code>Watermark</code>，这一步骤可以发生在拓扑图中的任意一个环节。</li>
</ol>
<h3 id="SourceContext的初始化"><a href="#SourceContext的初始化" class="headerlink" title="SourceContext的初始化"></a>SourceContext的初始化</h3><p>首先看下<code>SourceStream</code>算子的启动过程：</p>
<p><img src="/assets/img/sourcestream.jpg" alt="SourceStream算子的启动过程"></p>
<p><code>SourceContext</code>的作用主要是用于发射<code>elements</code>，也有可能发射<code>Watermark</code>，从Source算子启动的流程图中可以看出一共它有三种类型。SourceStream在启动的时候会根据配置的时间类型来选择对应的<code>SourceContext</code>，它的直接子类只有两个<code>WatermarkContext</code> 和 <code>NonTimestampContext</code>。</p>
<p><code>WatermarkContext</code>处理与<code>Watermark</code>相关的操作。也要维护当前Stream的<code>StreamStatus</code>，使stream的状态能正确传递给下游。这样做是因为<strong>流的状态能会影响下游到对<code>Watermark</code>的处理</strong>。下游处理<code>StreamStatus</code>和<code>Watermark</code>的相关逻辑可以参考<code>StatusWatermarkValve</code>，它会决定元素是否继续传递给下游。</p>
<p><code>WatermarkContext</code> 又有两个子类：  </p>
<ul>
<li><p>AutomaticWatermarkContext<br>  对应的配置是<code>IngestionTime</code>。它会启动一个定时任务，以固定的时间间隔从系统中提取系统时间作为<code>Watermark</code>发射到下游。</p>
</li>
<li><p>ManualWatermarkContext<br>  对应的配置是<code>EventTime</code>。用户通过它提供的方法可以主动发射<code>Watermark</code>。</p>
</li>
</ul>
<p><code>NonTimestampContext</code>发射的所有元素都不会携带时间戳，并且它也不不能发射<code>Watermark</code>。对应的配置是<code>ProcessingTime</code>，它不会产生<code>Watermark</code>，而是由<code>WindowOperator</code>在收到新元素时，直接根据当前系统时间判断是否要触发计算逻辑。</p>
<h3 id="AutomaticWatermarkContext逻辑"><a href="#AutomaticWatermarkContext逻辑" class="headerlink" title="AutomaticWatermarkContext逻辑"></a>AutomaticWatermarkContext逻辑</h3><p>注册定时任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private AutomaticWatermarkContext(...) &#123;</span><br><span class="line">	super(timeService, checkpointLock, streamStatusMaintainer, idleTimeout);</span><br><span class="line">	&#x2F;&#x2F; 初始化过程</span><br><span class="line">	...</span><br><span class="line">	&#x2F;&#x2F; 注册一个定时发射任务</span><br><span class="line">	long now &#x3D; this.timeService.getCurrentProcessingTime();</span><br><span class="line">	this.nextWatermarkTimer &#x3D; this.timeService.registerTimer(now + watermarkInterval,</span><br><span class="line">		new WatermarkEmittingTask(this.timeService, checkpointLock, output));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当收到一个元素时，会判断是否要发射<code>Watermark</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void processAndCollect(T element) &#123;</span><br><span class="line">	&#x2F;&#x2F; 取系统时间做为Watermark</span><br><span class="line">	lastRecordTime &#x3D; this.timeService.getCurrentProcessingTime();</span><br><span class="line">	&#x2F;&#x2F; 发射元素</span><br><span class="line">	output.collect(reuse.replace(element, lastRecordTime));</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; this is to avoid lock contention in the lockingObject by</span><br><span class="line">	&#x2F;&#x2F; sending the watermark before the firing of the watermark</span><br><span class="line">	&#x2F;&#x2F; emission task.</span><br><span class="line">	if (lastRecordTime &gt; nextWatermarkTime) &#123;</span><br><span class="line">		&#x2F;&#x2F; in case we jumped some watermarks, recompute the next watermark time</span><br><span class="line">		final long watermarkTime &#x3D; lastRecordTime - (lastRecordTime % watermarkInterval);</span><br><span class="line">		nextWatermarkTime &#x3D; watermarkTime + watermarkInterval;</span><br><span class="line">		output.emitWatermark(new Watermark(watermarkTime));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时任务 <code>WatermarkEmittingTask</code>，它是<code>AutomaticWatermarkContext</code>的内部类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private class WatermarkEmittingTask implements ProcessingTimeCallback &#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void onProcessingTime(long timestamp) &#123;</span><br><span class="line">		final long currentTime &#x3D; timeService.getCurrentProcessingTime();</span><br><span class="line"></span><br><span class="line">		synchronized (lock) &#123;</span><br><span class="line">			&#x2F;&#x2F; we should continue to automatically emit watermarks if we are active</span><br><span class="line">			if (streamStatusMaintainer.getStreamStatus().isActive()) &#123;</span><br><span class="line">				if (idleTimeout !&#x3D; -1 &amp;&amp; currentTime - lastRecordTime &gt; idleTimeout) &#123;</span><br><span class="line">				&#x2F;&#x2F; 检测stream的状态，如果超过一定时间没有元素进来，就会将此stream置位空闲状态从而影响下有对watermark的处理</span><br><span class="line">					markAsTemporarilyIdle();</span><br><span class="line">					cancelNextIdleDetectionTask();</span><br><span class="line">				&#125; else if (currentTime &gt; nextWatermarkTime) &#123;</span><br><span class="line">					&#x2F;&#x2F; 发射</span><br><span class="line">					final long watermarkTime &#x3D; currentTime - (currentTime % watermarkInterval);</span><br><span class="line">					output.emitWatermark(new Watermark(watermarkTime));</span><br><span class="line">					nextWatermarkTime &#x3D; watermarkTime + watermarkInterval;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		long nextWatermark &#x3D; currentTime + watermarkInterval;</span><br><span class="line">		&#x2F;&#x2F; 注册下一次的定时任务</span><br><span class="line">		nextWatermarkTimer &#x3D; this.timeService.registerTimer(nextWatermark, new WatermarkEmittingTask(this.timeService, lock, output));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TimestampsAndPeriodicWatermarksOperator"><a href="#TimestampsAndPeriodicWatermarksOperator" class="headerlink" title="TimestampsAndPeriodicWatermarksOperator"></a>TimestampsAndPeriodicWatermarksOperator</h3><p>是一个<code>StreamOperator</code>，可以在拓扑图中的任一环节。当job的时间类型为<code>EventTime</code>时，在拓扑图中需要增加这个算子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class TimestampsAndPeriodicWatermarksOperator &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	public void open() throws Exception &#123;</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		currentWatermark &#x3D; Long.MIN_VALUE;</span><br><span class="line">		watermarkInterval &#x3D; getExecutionConfig().getAutoWatermarkInterval();</span><br><span class="line">		&#x2F;&#x2F; 如果间隔大于0表示开启定时发射watermark任务</span><br><span class="line">		if (watermarkInterval &gt; 0) &#123;</span><br><span class="line">			long now &#x3D; getProcessingTimeService().getCurrentProcessingTime();</span><br><span class="line">			getProcessingTimeService().registerTimer(now + watermarkInterval, this);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void processElement(StreamRecord&lt;T&gt; element) throws Exception &#123;</span><br><span class="line">		final long newTimestamp &#x3D; userFunction.extractTimestamp(element.getValue(),</span><br><span class="line">				element.hasTimestamp() ? element.getTimestamp() : Long.MIN_VALUE);</span><br><span class="line">		&#x2F;&#x2F; 将element的时间戳替换为从elemnt中提取的时间戳</span><br><span class="line">		output.collect(element.replace(element.getValue(), newTimestamp));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void onProcessingTime(long timestamp) throws Exception &#123;</span><br><span class="line">		&#x2F;&#x2F; 从elemnt中提取时间戳</span><br><span class="line">		&#x2F;&#x2F; 这里有一个问题，如果上游一直没有发送元素并且也没切换StreamStatus就会导致watermark阻塞到下游，不能再向前传递</span><br><span class="line">		Watermark newWatermark &#x3D; userFunction.getCurrentWatermark();</span><br><span class="line">		if (newWatermark !&#x3D; null &amp;&amp; newWatermark.getTimestamp() &gt; currentWatermark) &#123;</span><br><span class="line">			currentWatermark &#x3D; newWatermark.getTimestamp();</span><br><span class="line">			output.emitWatermark(newWatermark);</span><br><span class="line">		&#125;</span><br><span class="line">		long now &#x3D; getProcessingTimeService().getCurrentProcessingTime();</span><br><span class="line">		getProcessingTimeService().registerTimer(now + watermarkInterval, this);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void processWatermark(Watermark mark) throws Exception &#123;</span><br><span class="line">		&#x2F;&#x2F; 忽略上游传递的watermarks，仅传递当前算子产生的时间戳。除了代表流结束的watermark</span><br><span class="line">		if (mark.getTimestamp() &#x3D;&#x3D; Long.MAX_VALUE &amp;&amp; currentWatermark !&#x3D; Long.MAX_VALUE) &#123;</span><br><span class="line">			currentWatermark &#x3D; Long.MAX_VALUE;</span><br><span class="line">			output.emitWatermark(mark);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下游对Watermark的处理"><a href="#下游对Watermark的处理" class="headerlink" title="下游对Watermark的处理"></a>下游对Watermark的处理</h2><p>下游接收上游数据的流程图：<br><img src="/assets/img/downstream.jpg" alt="下游接收上游数据过程"></p>
<p>从流程图中可以很清楚的看出来，<code>Watermark、StreamStatus</code>都是交给<code>StatusWatermarkValve</code>来进行处理。它相当于一个阀门，当收到水位线或者流的状态的时候判断是否满足相应的条件，如果满足才会再继续发射到下游。</p>
<p>首先看下阀门的一个内部类<code>InputChannelStatus</code>，这个类非常重要，它封装了上游<code>InputChannel</code>的状态，在计算过程中都会用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected static class InputChannelStatus &#123;</span><br><span class="line">	&#x2F;&#x2F; 最近一个水位线</span><br><span class="line">	long watermark;</span><br><span class="line">	&#x2F;&#x2F; 上游状态，Active 或者 Idle</span><br><span class="line">	StreamStatus streamStatus;</span><br><span class="line">	&#x2F;&#x2F; 标示上游的水位线是否对齐，只有对齐时才会使用水位线</span><br><span class="line">	boolean isWatermarkAligned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理水位线的大致流程如下：<br><img src="/assets/img/inputwatermark.jpg" alt="处理水位线"></p>
<p>这个流程复杂，重点看下如何找最小的水位线，这一步骤决定是否发射新的水位线到下游。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void findAndOutputNewMinWatermarkAcrossAlignedChannels() &#123;</span><br><span class="line">	long newMinWatermark &#x3D; Long.MAX_VALUE;</span><br><span class="line">	boolean hasAlignedChannels &#x3D; false;</span><br><span class="line">	&#x2F;&#x2F; 找最小的水位线</span><br><span class="line">	for (InputChannelStatus channelStatus : channelStatuses) &#123;</span><br><span class="line">		if (channelStatus.isWatermarkAligned) &#123;</span><br><span class="line">			hasAlignedChannels &#x3D; true;</span><br><span class="line">			newMinWatermark &#x3D; Math.min(channelStatus.watermark, newMinWatermark);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 由于所有的InputChannelStatus默认都是激活、对齐，且水位线&#x3D;Long.MIN_VALUE。</span><br><span class="line">	&#x2F;&#x2F; 如果某个上游（InputChannel）一直没有发送新的水位线且也没有切换状态。</span><br><span class="line">	&#x2F;&#x2F; 这样newMinWatermark的值一直都是Long.MIN_VALUE，从而不会发射新的watermark</span><br><span class="line">	&#x2F;&#x2F; 上述情况在EventTime时，可能会发生。</span><br><span class="line">	if (hasAlignedChannels &amp;&amp; newMinWatermark &gt; lastOutputWatermark) &#123;</span><br><span class="line">		lastOutputWatermark &#x3D; newMinWatermark;</span><br><span class="line">		outputHandler.handleWatermark(new Watermark(lastOutputWatermark));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理<code>StreamStatus</code>的过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void inputStreamStatus(StreamStatus streamStatus, int channelIndex) &#123;</span><br><span class="line">	if (streamStatus.isIdle() &amp;&amp; channelStatuses[channelIndex].streamStatus.isActive()) &#123;</span><br><span class="line">		&#x2F;&#x2F; 处理active -&gt; idle的切换</span><br><span class="line">		channelStatuses[channelIndex].streamStatus &#x3D; StreamStatus.IDLE;</span><br><span class="line">		&#x2F;&#x2F; 当channel位idle状态时，设置为非对齐状态，不会影响找newMinWatermark</span><br><span class="line">		channelStatuses[channelIndex].isWatermarkAligned &#x3D; false;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 如果所有的上游都为idle，就会给下游发送idle，并且当前的算子状态也置为idle</span><br><span class="line">		if (!InputChannelStatus.hasActiveChannels(channelStatuses)) &#123;</span><br><span class="line"></span><br><span class="line">			if (channelStatuses[channelIndex].watermark &#x3D;&#x3D; lastOutputWatermark) &#123;</span><br><span class="line">				findAndOutputMaxWatermarkAcrossAllChannels();</span><br><span class="line">			&#125;</span><br><span class="line">			lastOutputStreamStatus &#x3D; StreamStatus.IDLE;</span><br><span class="line">			outputHandler.handleStreamStatus(lastOutputStreamStatus);</span><br><span class="line">		&#125; else if (channelStatuses[channelIndex].watermark &#x3D;&#x3D; lastOutputWatermark) &#123;</span><br><span class="line">			&#x2F;&#x2F; 重新找newMinWatermark，且有可能 newMinWatermark &gt; channelStatuses[channelIndex].watermark</span><br><span class="line">			findAndOutputNewMinWatermarkAcrossAlignedChannels();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else if (streamStatus.isActive() &amp;&amp; channelStatuses[channelIndex].streamStatus.isIdle()) &#123;</span><br><span class="line">		&#x2F;&#x2F; 处理idle -&gt; active的切换</span><br><span class="line">		channelStatuses[channelIndex].streamStatus &#x3D; StreamStatus.ACTIVE;</span><br><span class="line">		&#x2F;&#x2F; 对齐</span><br><span class="line">		if (channelStatuses[channelIndex].watermark &gt;&#x3D; lastOutputWatermark) &#123;</span><br><span class="line">			channelStatuses[channelIndex].isWatermarkAligned &#x3D; true;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 重新激活当前算子</span><br><span class="line">		if (lastOutputStreamStatus.isIdle()) &#123;</span><br><span class="line">			lastOutputStreamStatus &#x3D; StreamStatus.ACTIVE;</span><br><span class="line">			outputHandler.handleStreamStatus(lastOutputStreamStatus);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Flink%E6%BA%90%E7%A0%81/">Flink源码</a><a class="link-muted mr-2" rel="tag" href="/tags/Flink/">Flink</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/03/08/%E7%89%B9%E5%BE%81%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%80%EF%BC%89/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">特征平台（一）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/02/18/%E6%9C%8D%E5%8A%A1%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/"><span class="level-item">服务超时问题</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.2/gitalk.css"><script src="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.2/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: 'a4800b1dfae212e9fbcb692347cd8b51',
            repo: 'gitcomment',
            owner: 'mjz-cn',
            clientID: '658c65c1d7c320c954dc',
            clientSecret: '6dc7a2602f2f71971609da6b699247f4d5278c05',
            admin: ["mjz-cn"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: 'last',
            
            
            enableHotKey: true
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#简介"><span class="mr-2">1</span><span>简介</span></a></li><li><a class="is-flex" href="#Watermark来源"><span class="mr-2">2</span><span>Watermark来源</span></a><ul class="menu-list"><li><a class="is-flex" href="#SourceContext的初始化"><span class="mr-2">2.1</span><span>SourceContext的初始化</span></a></li><li><a class="is-flex" href="#AutomaticWatermarkContext逻辑"><span class="mr-2">2.2</span><span>AutomaticWatermarkContext逻辑</span></a></li><li><a class="is-flex" href="#TimestampsAndPeriodicWatermarksOperator"><span class="mr-2">2.3</span><span>TimestampsAndPeriodicWatermarksOperator</span></a></li></ul></li><li><a class="is-flex" href="#下游对Watermark的处理"><span class="mr-2">3</span><span>下游对Watermark的处理</span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">MJZ</a><p class="size-small"><span>&copy; 2022 文哲思</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>